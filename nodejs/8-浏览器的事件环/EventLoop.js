// 浏览器的EventLoop ：事件触发线程
// 进程包含线程
//我们写的是一个应用，每个应用就是一个进程，进程又包含线程
//例如我们点开电脑的任务管理器，查看正在使用的Visual Studio Code，Visual Studio Code是一个应用，我们发现它会又不只一个进程（进程是cpu资源分配的最小单位（系统会给它分配内存）），每个进程中又会包含着n个线程；

//js是主线程是单线程的

//浏览器是多进程模型
//浏览器每个页卡（页卡就是每次进入的网址）都是一个独立的进程



/*
我们主要关心的是浏览器的渲染进程（也就是浏览器的内核）



浏览器的渲染进程主要指的是：页面渲染和js执行
页面渲染是线程，js执行也是线程，页面渲染不能执行js，js执行不能执行页面渲染
页面渲染和js是互斥的两个只能一个一个的执行，不能同时执行

假如js是多线程，线程一要删除dom，而线程二要添加dom，这时浏览器不就懵逼了不知道要听谁的了，所以js为单线程是合理的




1、js默认是由多个线程但是主线程是单线程，所以js代码执行是从上到小，从左到右
但是v8引擎或者一些api中提供了一些方法例如 ajax、事件、promise等这些我们叫做异步方法
异步方法就不会马上执行。例如调用ajax是等ajax成功后结果返回再去调用回调来通知我，成功了


异步方法要等待同步执行完后在执行异步代码但这样的说法并不准确其实
像这些异步的方法，浏览器执行js时是会有一个单独的线程去管理代码执行的逻辑，调度整个执行流程（那你就会有疑问了js执行不是单线程怎么又多了一个线程，浏览执行js的主线程是单线程的，默认则是多线程的）
*/


/*
进程是计算机分配任务的最小单位
进程里又包含好多线程，线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）

*/

/*
js在浏览器的渲染进程中一般只包含一条主线程（其实还会包含别的线程我不考虑）
*/



/*
宏任务：宿主环境提供例如script ajax等也就是浏览器提供的
微任务：语言本身提供的例如Promise等


*/


/*
浏览器的事件环执行顺序：
先执行js引擎线程 也就是srcipt标签中的js代码但是js中又分为宏任务和微任务，遇到微任务的时候会将微任务放到一个队列中，遇到宏任务时在将宏任务放到一个对列中，待同步代码执行完成后，去清空微任务对列，之后浏览器去渲染，渲染后在去执行宏任务队列中的第一个宏任务（宏任务是不会清空的只能一个个执行），在执行宏任务中，当遇到
微任务，在将微任务放到一个队列中，当到宏任务，再将宏任务放到一个队列中，当同步的执行完毕之后在在去清空微任务，之后在渲染，之后在执行宏任务对列之中的下一个宏任务，以此循环执行，形成事件环
*/


/*
宏任务： setTimeout() script标签  ui渲染   setImmediate(仅iez支持)  messageChannel requestAnimationFrame   
 node中i/o   ajax  事件


微任务： Promise的then     mutationObserver     node中的:processs.nextTick    queueMircoTask (queueMircoTask是基于Promise的，说白里它即使promise的then方法)

*/

