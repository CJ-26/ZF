setTimeout(() => {   // v8引擎提供的宏任务
  console.log("宏任务")
},1000);

Promise.resolve("微任务").then(res=>{  //es6语法提供promise微任务
  console.log(res)
})
function a(){
  function b(){
    function c(){
      console.log("1000")
    }
    c()
  }
  b()
}

a()  
// 执行输出：先输出：1000   之后：微任务  在之后：宏任务


/*
浏览器时如何执行的那：
浏览器会创建两个队列，一个是宏任务的一个是微任务的，
当代码执行时例如上面的例子，代码由上到下执行，
遇到setTimeout会将它放到宏任务队列中但是不是马上就放进去，例如setTimeout为一秒后执行，那就要等到一秒后才会放进宏任务队列中，也可以说宏任务是单独的一条线程
遇到Promise时会立即放入微任务队列中，
待同步代码执行完毕后会立即清空微任务，之后渲染页面，之后在去走宏任务，但是宏任务队列是不会清空的，去走宏任务队列中的第一个放进来的宏任务
这里就走setTimeout，setTimeout里面如果由微任务，在放到微任务对列中，如果有宏任务再放到宏任务队列中，之后走完同步在去清空微任务再去渲染再去走宏任务对列中的下一个宏任务






注意：
渲染页面这个过程不一定每次都会执行，浏览器自己会做优化是不可控，但是只要执行了就一定会在清空微任务后执行

*/

//队列的概念：先放进来的先出去，