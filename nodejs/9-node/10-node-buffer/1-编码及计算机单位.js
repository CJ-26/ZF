// Buffer 代表二进制对象：

//浏览器前期没有H5的时候，浏览器是没有读写操作的，但那时浏览器也有二进制对象Blob后来又有了File(File是继承Blob的)


// 那么现在js在node环境下运行，需要对文件的二进制处理，因为前端传递的文件都是二进制对象
//而Buffer就是方便二进制和字符串之间的转化的；


//常用的进制转化有  二进制  十进制  十六进制

/*
计算机单位：
位：计算机最小的数据单位，每一位只能是0或1

字节（Byte）：8个二进制构成一个字节，是存储空间的基本构成单位，一个英文字母占一个字节，在不同编码集中中文的占位不同，GBK中一个汉字占俩个字节；UTF-8一个汉字占3个字节

KB：1KB代表1024个字节


MB：也就是我们日常生活中所说的兆，通常在计算过程中粗略的记为1MB=10^6（10的6次方）  字节；实际上是1024^2



也就是说一个字节是由八个位组成的八个位存放的都是0和1的二进制数最大为八个一最小为八个0
一个字节最大转化为十进制为255 


*/



/*
编码规范：
最早计算机是从美国开始发展所以美国的计算机编码规是由字母的大小写和一些特殊字符组成叫做ASCII码，ASCII码从0开始排最大为127，每一数对应着一个字母或者一个特殊字符，而计算机的单位都是由二进制组成所以ASCII码最小0，最大是01111111(为何01111111前面要加零因为计算机最小单位为：
  位。一位只能表示0或者1，比位大的是字符，一个字符包含八个位，而ASCII码最大二进制表示位1111111，转化为字符一共有7个1少了一位所以前面补零就为01111111。
  又因为字符最大可以存放11111111转为十进制为255，而ASCII码中最大为127所以，所有的ASCII都可以用一个字符来表示，位数不够在前面补零
  所以我们可以是字母何字符都是由一个字节来组成的

  但ASCII码只是对一些国家能用因为最大只有127在我国那么多汉字肯定不够用所以我先制定了国标字体（GB2312）,GB231组合最大由两个字节组成，一个字节最大是11111111十进制是255，两个字节最大是1111111111111111转换为十进制为65025也就是有65025个国标字体最开始定义的时候并没有全部使用
  之后又制定了GBK（国标扩展字体）把GB2312中定义没有使用给使用了一些但是后来发现BGK也不够够这时又定制了GB18030把一些少数民族的字体也加了进去，GB2312  GBK  GB18030 都是一个汉字两个字节，


  每个国家的字体不同制定规范也不同例如GBK只能针对中国，这时就有一个组织想统一规范叫unicode但是unicode没有发展起来最终没有实现统一之后
  出现了一个utf8给统一了
  utf8的表现形式为 1字节到4字节可变的字节长度(但对于汉字而言utf8是用3个字节来转化的也汉字由3个字节组成，字母和字符仍然遵循ASCII是1个字节)


node中是不支持GBK编码的只支持utf8（汉字为3个字节，字母和字符为1个字节）

*/


/*
2进制是以0b开头
16进制是以0x开头
8进制是以0开头
*/



/*
进制转化方法：
想把任意进制转化为10进制 parseInt()
用法:parseInt()有两个参数参数一位要转的数，参数二要转的数是几进制
例如：
let n = parseInt("1111",2)    // 要把二进制的1111转为十进制，parseInt参数一就是1111参数二就是2因为1111是二进制所以参数二就是2
console.log(n) // 15

let n1 = parseInt("ff",16)
console.log(n1) //255
或者这样写：
let n1 = parseInt("0xff",16)  //把十六进制的0x标识加上但必须是字符串
console.log(n1) //255





把任意进制转化为任意进制：toString()  （注意toString转完的数是字符串）
用法;转换的数点上toString(要转成几进制就写几),
let b= 0xf.toString(2)  // 十六机制数转2进制，十六进制数需要加0x标识
console.log(b)

let b1 = 0b100.toString(10)  //0b为二进制标识，将2进制转为十进制数
console.log(b1)  // 4

let b2 = 010.toString(10)  //0为八进制标识，将八进制转为十进制数
console.log(b2)  // 8


  

console.log(255.toString(16)) // 语法错误，js不支持该语法。
数字转成字符串，必须先将数字绑定到一个变量上。
let num = 255;
console.log(num.toString(16));  // ff

*/


/*
运算符 |(或)  &(与)   <<(左位移)   >>(右位移)   ~(非)  ^(异或)针对的二进制使用的

二进制左位移运算符(<<): 相当于乘以2的几次方    
console.log(1<<1)输出2   1乘以2的1次方    可理解为000000001 最后一位向左移动一位0000010 转为二进制就是2

console.log(3<<2)输出进制数15   3乘以2的2次方  
console.log(0b101<<2)输出为十进制数20     可理解为00000101 最后一位向左移动两位，先移动一位是00000110在移动一位发先前面不是0那就在后面补一个零00001100转为十进制就是20






二进制右位移运算符(>>): 相当于除以2的几次方
 4 >> 2  //1   相当于 2除以(2的2次方)    可理解为十进制4转化为二进制位100，右边第一位向左移动两位，先移动一位为010在移动一位位001所以001转化成十进制为1
 
 5(十进制) >> 3 相当于 5/(2的三次方)





二进制或运算符(|): 如果两个符号位都为0,则结果为0,否则为1
两个二进制数是从右向左对比如果都是1就返回1如果有1有0就返回1如果都是0则返回零
1100 | 0101 返回 1101  //解释：右向左对比 1100和0101，最左边第一位为0和1所以返回1 ，第二位为0和0 返回0 第三位为1和1所以返回1  ， 第四位为1和零返回1 结果就是1101





二进制与运算符(&): 如果两个符号位都为1,则结果为1,否则为0
两个二进制数是从右向左对比如果都是1就返回1如果有1有0就返回0如果都是0则返回零
1100 & 0101 返回 0100  //解释右向左对比 1100和0101，最左边第一位为0和1所以返回0 ，第二位为0和0 返回0 第三位为1和1所以返回1  ， 第四位为1和零返回0 结果就是：0100 





二进制非运算符(~): (一元运算符)取反,二进制位0变1,1变0
~1100 返回 0011  // 就是1变0，0变1




二进制异或运算符(^): 若两个二进制位相同,则结果为0;否则为


*/





/*
base64编码：
一、作用：
1、用于传输 http请求的头(headers)headers中是不能有中文的所以可以使用base64格式传输
2、用于传输图片（图片转base64）

二、如何把一个汉字变成base64编码：
例如将：珠转为base64的格式：
utf8编码一个汉字由3个字符组成，24个位，
首先要知道Buffer中有个方法为Buffer.from()该方法是把一个汉字转成2进制但是表现形式为16进制的（就说Buffer.from将汉字实质上是转为了2进制你看到的是16进制也就是打印输出的是16进制的）
console.log(Buffer.from("珠"))  //<Buffer e7 8f a0>   e7 8f a0分别代表十六进制标识的3个字节
//将<Buffer e7 8f a0>中的e7 8f a0转成二进制：
console.log(0xe7.toString(2))  //11100111
console.log(0x8f.toString(2))  //10001111 
console.log(0xa0.toString(2))  // 10100000
//也就是Buffer e7 8f a0>中的e7 8f a0转成二进制为： 11100111 、 10001111 、 10100000

base64规定字节中的每一位最大不能大于十进制的64有也就值2进制最大值为0b111111,(0b111111转为十进制为63)
由utf8编码可知一个汉字是由3个字节组成一个字节是由八个位组成，每个位只能存放0或者1，那如何保证不大于十进制的64，也就是小于等于63了
一个字节由八位而十进制的63转为2进制位0b111111，只有六个字节，还差两二位所以只要保证一个字节的前两位都是零就可以了：00111111
为了方便base64编码规定不采用一个汉字由3个字节组成一个字节由8位组成也就是汉子由24位组成也就是3乘以8的格式，
而base64想到了反正是24个字节4乘以6也等于24，就是使用4*6的格式，

4*6的格式如下：
先将珠字转成的二进制都拼接起来：
111001111000111110100000
之后没六个一组分成4组：
111001   111000   111110  100000
计算机的一个字节是由八位组成这才六位所以会在前面补两个0也就是：00111001   00111000   00111110  00100000这样就能保证base64最大十进制的值为63
原先是3个字节组成现在是4个字节组成所以就是3+3*x = 4 x就是1/3 所以转位base64会比原先大1/3
也就是说不是所有图片都适合转成base64比如一张比较大的图片就不适合转成base64例如一张10兆的转完就变成13兆了


base64转码规则：将base64的4*6的格式中的四组二进制数先转为10进制
之后在将26个大写英文字母拼接上26小写英文在拼接上0123456789+/成一个字符串记住顺序不能乱
之后将转成十进制的4个数当作下标去拼接成字符串中取出对应的值在拼接在一起就是base64编码了
console.log(parseInt(0b00111001)) //57
console.log(parseInt(0b00111000)) //56
console.log(parseInt(0b00111110)) //62
console.log(parseInt(0b00100000)) // 32
let str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
str+=str.toLowerCase();将大写字母转为小写字母
str+="0123456789+/"
console.log(str[57]+str[56]+str[62]+str[32]) //54+g





base64的优点是：
1.可以放在任意替代的url路径上例如图片 链接

注意base64是不能用于加密的
*/




